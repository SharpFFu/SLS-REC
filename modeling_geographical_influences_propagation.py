# -*- coding: utf-8 -*-
"""Modeling geographical influences propagation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dn4ANhfZcc6wEB5EB_v_vPZ8ZfNJv-qR
"""

from collections import defaultdict



class POI(object):
    def __init__(self, pid, lat, lng, freq, center=-1):
        self.pid = pid
        self.lat = lat
        self.lng = lng
        self.freq = freq
        self.center = center


class Center(object):
    def __init__(self):
        self.pois = []
        self.total_freq = 0
        self.lat = None
        self.lng = None

    def add(self, poi):
        self.pois.append(poi)
        self.total_freq += poi.freq


class GeographyMultiCenterModel(object):
    def __init__(self, alpha=0.2, theta=0.02, dmax=50):
        self.alpha = alpha
        self.theta = theta
        self.dmax = dmax
        self.poi_coos = None
        self.center_list = None
        self.hist = None

    def build_user_check_in_profile(self, sparse_check_in_matrix):
        Hist = defaultdict(list)
        for (uid, pid), freq in sparse_check_in_matrix.items():
            lat, lng = self.poi_coos[pid]
            Hist[uid].append(POI(pid, lat, lng, freq))
        return Hist

    def discover_user_centers(self, hist_u):
        center_min_freq = max(sum([poi.freq for poi in hist_u]) * self.theta, 2)
        hist_u.sort(key=lambda k: k.freq, reverse=True)
        center_list = []
        center_num = 0
        for i in range(len(hist_u)):
            if hist_u[i].center == -1:
                center_num += 1
                center = Center()
                center.add(hist_u[i])
                hist_u[i].center = center_num
                for j in range(i + 1, len(hist_u)):
                    if hist_u[j].center == -1 and euclidean_dist(hist_u[i], hist_u[j]) <= self.dmax:
                        hist_u[j].center = center_num
                        center.add(hist_u[j])
                if center.total_freq >= center_min_freq:
                    center_list.append(center)
        return center_list

    def multi_center_discover(self, sparse_check_in_matrix, poi_coos):
        self.poi_coos = poi_coos
        self.hist = self.build_user_check_in_profile(sparse_check_in_matrix)
        center_list = {}
        u_centers = {}
        for uid in range(len(self.hist)):
            center_pids = []
            center_list[uid] = self.discover_user_centers(self.hist[uid])
            for it in center_list[uid]:
                center_pids.append(it.pois[0].pid)
            u_centers[uid] = center_pids
        return u_centers
class GeographicalModule(object):
    def __init__(self, alpha = 0.3):
        self.upsilon = None
        self.user_normal_dist = None
        self.phi = None
        self.poi_normal_dist = None

        self.alpha = alpha
        self.check_in_matrix = None
        self.poi_coos = None

    def save_result(self, path):
        ctime = time.time()
        print("Saving GeographicalModule result...")
        print("1.Saving UserModel result...")
        np.save(path + "upsilon", self.upsilon)
        np.save(path + "user_normal_dist", self.user_normal_dist)

        print("2.Saving POIModel result...")
        np.save(path + "phi", self.phi)
        np.save(path + "poi_normal_dist", self.poi_normal_dist)
        print("Done. Elapsed time:", time.time() - ctime, "s")

    def load_result(self, path):
        ctime = time.time()
        print("Loading GeographicalModule result...")
        print("1.Loading UserModel result...")
        self.upsilon = np.load(path + "upsilon.npy")
        self.user_normal_dist = np.load(path + "user_normal_dist.npy")

        print("2.Loading POIModel result...")
        self.phi = np.load(path + "phi.npy")
        self.poi_normal_dist = np.load(path + "poi_normal_dist.npy")
        print("Done. Elapsed time:", time.time() - ctime, "s")

    def UserModel(self, check_in_matrix, poi_coos, user_centers):
        ctime = time.time()
        print("Training UserModel...")
        normal_dist = []
        upsilon = []
        for uid in range(check_in_matrix.shape[0]):
            uid_pids = check_in_matrix[uid, :].nonzero()[0]
            tohome_dist = []
            pid_normal_dist = []
            for i in uid_pids:
                h_dist = np.mean([euclidean_dist(poi_coos[i], poi_coos[cid]) for cid in user_centers[uid]])
                tohome_dist.append(h_dist)
            if len(tohome_dist) == 0:
              pass
            else:
              uid_activity_dist = np.max(tohome_dist)

              for i in uid_pids:
                  for cid in user_centers[uid]:
                      h_dist = uid_activity_dist * euclidean_dist(poi_coos[i], poi_coos[cid])
                      pid_normal_dist.append(h_dist)
              if uid ==6928:
                break
              upsilon.append(uid_activity_dist)
              normal_dist.append(gaussian_fun(pid_normal_dist))
        self.upsilon = np.array(upsilon)
        self.user_normal_dist = np.array(normal_dist)
        print("Done. Elapsed time:", time.time() - ctime, "s")

    def POIModel(self, check_in_matrix, poi_coos):
        self.poi_coos = poi_coos
        self.check_in_matrix = check_in_matrix
        ctime = time.time()
        print("Training POIModel...", )
        normal_dist = []
        phi = []
        for uid in range(check_in_matrix.shape[0]):
            print(uid)
            uid_pids = check_in_matrix[uid, :].nonzero()[0]
            visited_dist = []
            lid_normal_dist = []
            for i in range(len(uid_pids)):
                for j in range(i + 1, len(uid_pids)):
                    v_dist = euclidean_dist(poi_coos[uid_pids[i]], poi_coos[uid_pids[j]])
                    visited_dist.append(v_dist)
            uid_mean_visited_dist = np.mean(visited_dist)

            for i in uid_pids:
                for k in range(check_in_matrix.shape[1]):
                    if i != k:
                        v_dist = uid_mean_visited_dist * euclidean_dist(poi_coos[i], poi_coos[k])
                        lid_normal_dist.append(v_dist)

            phi.append(uid_mean_visited_dist)
            normal_dist.append(gaussian_fun(lid_normal_dist))
            print(uid_mean_visited_dist,gaussian_fun(lid_normal_dist))
        self.phi = np.array(phi)
        self.poi_normal_dist = np.array(normal_dist)
        print("Done. Elapsed time:", time.time() - ctime, "s")

    def predict(self, uid, pid, check_in_matrix, poi_coos, user_centers):
        uid_pids = check_in_matrix[uid, :].nonzero()[0]
        user_centers_dist = []
        user_visited_dist = []
        for cid in user_centers[uid]:
            f_dist = self.upsilon[uid] * euclidean_dist(poi_coos[cid], poi_coos[pid])
            user_centers_dist.append(f_dist)
        pro_user = gaussian_fun(user_centers_dist) / self.user_normal_dist[uid]

        for j in uid_pids:
            f_dist = self.phi[uid] * euclidean_dist(poi_coos[j], poi_coos[pid])
            user_visited_dist.append(f_dist)
        pro_poi = gaussian_fun(user_visited_dist) / self.poi_normal_dist[uid]

        pro = self.alpha * pro_user + (1-self.alpha) * pro_poi
        return pro
import time
import numpy as np


class CheckinModule(object):
    def __init__(self, num_factors, reg_lambda=0.6, gamma_lmf=1.0, iters=30):
        self.num_factors = num_factors
        self.iters = iters
        self.reg_lambda = reg_lambda
        self.gamma_lmf = gamma_lmf

    def save_result(self, path):
        ctime = time.time()
        print("Saving CheckinModule result...")
        np.save(path + "user_vectors", self.user_vectors)
        np.save(path + "user_biases", self.user_biases)
        np.save(path + "poi_vectors", self.poi_vectors)
        np.save(path + "poi_biases", self.poi_biases)

        print("Done. Elapsed time:", time.time() - ctime, "s")

    def load_result(self, path):
        ctime = time.time()
        print("Loading CheckinModule result...")
        self.user_vectors = np.load(path + "user_vectors.npy")
        self.user_biases = np.load(path + "user_biases.npy")
        self.poi_vectors = np.load(path + "poi_vectors.npy")
        self.poi_biases = np.load(path + "poi_biases.npy")
        print("Done. Elapsed time:", time.time() - ctime, "s")

    def train(self, check_in_matrix):
        self.check_in_matrix = check_in_matrix
        self.num_users, self.num_pois = self.check_in_matrix.shape[0], self.check_in_matrix.shape[1]
        self.ones = np.ones((self.num_users, self.num_pois))
        self.user_vectors = np.random.normal(size=(self.num_users, self.num_factors))
        self.poi_vectors = np.random.normal(size=(self.num_pois, self.num_factors))
        self.user_biases = np.random.normal(size=(self.num_users, 1))
        self.poi_biases = np.random.normal(size=(self.num_pois, 1))

        user_vec_deriv_sum = np.zeros((self.num_users, self.num_factors))
        poi_vec_deriv_sum = np.zeros((self.num_pois, self.num_factors))
        user_bias_deriv_sum = np.zeros((self.num_users, 1))
        poi_bias_deriv_sum = np.zeros((self.num_pois, 1))

        for i in range(self.iters):
            ctime = time.time()
            user_vec_deriv, user_bias_deriv = self.deriv(True)
            user_vec_deriv_sum += np.square(user_vec_deriv)
            user_bias_deriv_sum += np.square(user_bias_deriv)
            vec_step_size = self.gamma_lmf / np.sqrt(user_vec_deriv_sum)
            bias_step_size = self.gamma_lmf / np.sqrt(user_bias_deriv_sum)
            self.user_vectors += vec_step_size * user_vec_deriv
            self.user_biases += bias_step_size * user_bias_deriv

            poi_vec_deriv, poi_bias_deriv = self.deriv(False)
            poi_vec_deriv_sum += np.square(poi_vec_deriv)
            poi_bias_deriv_sum += np.square(poi_bias_deriv)
            vec_step_size = self.gamma_lmf / np.sqrt(poi_vec_deriv_sum)
            bias_step_size = self.gamma_lmf / np.sqrt(poi_bias_deriv_sum)
            self.poi_vectors += vec_step_size * poi_vec_deriv
            self.poi_biases += bias_step_size * poi_bias_deriv
            print('iteration %i finished in %f seconds' % (i + 1, time.time() - ctime))

    def deriv(self, user):
        if user:
            vec_deriv = np.dot(self.check_in_matrix, self.poi_vectors)
            bias_deriv = np.expand_dims(np.sum(self.check_in_matrix, axis=1), 1)
        else:
            vec_deriv = np.dot(self.check_in_matrix.T, self.user_vectors)
            bias_deriv = np.expand_dims(np.sum(self.check_in_matrix, axis=0), 1)

        A = np.dot(self.user_vectors, self.poi_vectors.T)
        A += self.user_biases
        A += self.poi_biases.T
        A = np.exp(A)
        A /= (A + self.ones)
        A = (self.check_in_matrix + self.ones) * A

        if user:
            vec_deriv -= np.dot(A, self.poi_vectors)
            bias_deriv -= np.expand_dims(np.sum(A, axis=1), 1)
            vec_deriv -= self.reg_lambda * self.user_vectors
        else:
            vec_deriv -= np.dot(A.T, self.user_vectors)
            bias_deriv -= np.expand_dims(np.sum(A, axis=0), 1)
            vec_deriv -= self.reg_lambda * self.poi_vectors
        return (vec_deriv, bias_deriv)

    def predict(self, uid, pid):
        A = (self.user_vectors[uid].dot(self.poi_vectors[pid])) + self.user_biases[uid] + self.poi_biases[pid]
        A = np.exp(A)
        pro = A / (1 + A)
        return pro

class GraphConvolution(nn.Module):
    def __init__(self, in_features, out_features, bias=True):
        super(GraphConvolution, self).__init__()
        self.in_features = in_features
        self.out_features = out_features
        self.weight = Parameter(torch.FloatTensor(in_features, out_features))
        if bias:
            self.bias = Parameter(torch.FloatTensor(out_features))
        else:
            self.register_parameter('bias', None)
        self.reset_parameters()

    def reset_parameters(self):
        stdv = 1. / math.sqrt(self.weight.size(1))
        self.weight.data.uniform_(-stdv, stdv)
        if self.bias is not None:
            self.bias.data.uniform_(-stdv, stdv)

    def forward(self, input, adj):
        support = torch.mm(input, self.weight)
        output = torch.spmm(adj, support)
        if self.bias is not None:
            return output + self.bias
        else:
            return output

    def __repr__(self):
        return self.__class__.__name__ + ' (' \
               + str(self.in_features) + ' -> ' \
               + str(self.out_features) + ')'


class GCN(nn.Module):
    def __init__(self, ninput, nhid, noutput, dropout):
        super(GCN, self).__init__()

        self.gcn = nn.ModuleList()
        self.dropout = dropout
        self.leaky_relu = nn.LeakyReLU(0.2)

        channels = [ninput] + nhid + [noutput]
        for i in range(len(channels) - 1):
            gcn_layer = GraphConvolution(channels[i], channels[i + 1])
            self.gcn.append(gcn_layer)

    def forward(self, x, adj):
        for i in range(len(self.gcn) - 1):
            x = self.leaky_relu(self.gcn[i](x, adj))

        x = F.dropout(x, self.dropout, training=self.training)
        x = self.gcn[-1](x, adj)

        return x